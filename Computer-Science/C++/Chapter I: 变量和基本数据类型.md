# 第一章 语法基础

[tips]
C++ 未定义任何 IO 语句，而是通过标注库来提供 IO 机制；

通常使用 iostream 库，iostream 库包括 istream 和 ostream 两个基本类型；

istream 基本类型包括 cin 对象；

ostream 基本类型包括 cout、cerr 和 clog 对象；

endl 这一操纵符的效果是结束当前行，并将于设备关联的缓冲区中的内容刷到设备中而不是仅停留在内存中。

关于 C++ 编译器，通过 
```
$ g++ -o program program.cpp
```

## 1. 变量

几乎所有的语言的基本语法内容包括：

- 基本数据类型
- 变量
- 表达式与语句
- 流程控制语句
- 函数
- 自定义数据类型（ADT）
- 类

变量就是一个具名的存储空间，C++ 每个变量都有数据类型，因而决定了该变量的存储空间、取值范围以及操作方法等。

- 变量定义

```
int x, y = 0;
Book book;
```

[注]
这里的对象，指的是具有某种数据类型的内存空间。

记住，C++ 中初始化和赋值时两种完全不同的操作；

- 初始化

初始化是创建变量时赋予其一个初始值，赋值则是把对象的当前值给擦除掉，而用新值替代。

```cpp
// 初始化
double price = 10.99;

// 赋值
price = 20;
```

有以下几种形式进行初始化：

```cpp

int a = 0;
int a = {0};

// 列表初始化
int a{0}; // C++ 11 新标准
int a(0);
```

默认初始化

1. 定义变量时未指定初值时，变量默认初始化，其值由变量类型以及定义变量的位置共同决定；

2. 内置类型的变量未被显式初始化，其值由定义的位置决定

3. 定义与函数体之外的变量被初始化为 0

4. 定义于函数体内部的内置类型变量将不被初始化 ？

4. 每个类各自决定其初始化对象的方式

由于 C++ 在未给变量赋初始值时的多变性，所以严格建议在变量创建之初进行初始化操作，尤其是初始化每一个内置类型的变量；

- 变量的定义与声明关系

如果需要在多个文件中使用同一个变量，那么就可以通过声明机制实现这一需求。

```cpp

// 变量当且仅当被定义一次
int a;

// 通过 extern 关键字标记变量，在不同文件中使用，注意不要给 i 赋初始值，不然就变成定义变量
extern int i;
```

[静态类型语言]

C++ 是静态类型语言，其含义是在编译阶段检查类型，因为对象的类型决定其所能进行的运算，如果编译器发现其试图执行类型不支持的运算，编译器将报错。




## 2. 基本类型

【静态类型 vs 动态类型】

静态类型 statically: 如果在编译时拒绝ill behaved程序，则是statically typed;
动态类型dynamiclly: 如果在运行时拒绝ill behaviors, 则是dynamiclly typed;

静态类型可以分为两种：
如果类型是语言语法的一部分，在是explicitly typed显式类型；
如果类型通过编译时推导，是implicity typed隐式类型, 比如ML和Haskell

---

数据类型是程序的基础，它的意义在于告诉我们数据的意义以及在数据上能执行的操作；

C++ 的基本数据类型包括基本内置类型（整型、浮点型、字符），标准库定义的复杂数据类型（可变长字符串、向量），以及自定义数据类型机制；

- 基本内置类型

基本内置类型包括算术类型和空类型；

算术类型包括整型、浮点型数，字符、布尔值等，空类型为 void；

不同数据类型表示了该数据的所占空间大小、表示的取值范围和对应的操作等；

[ASCII vs Unicode vs UTF-8]

[浮点数的知识]？

![](http://o97duqgf5.bkt.clouddn.com/18-1-30/93319039.jpg)

- 数据类型转换

![](http://o97duqgf5.bkt.clouddn.com/18-1-31/98549681.jpg)

[疑问]

有符号类型的数值进行向无符号类型转换时的转换规则？

- 字面量（字面值常量）

每个字面量常量对应一种数据类型，其形式和类型决定了它的数据类型。

数值字面量

```
20  024/* 八进制 */ 0x14 /* 十六进制 */
```

字符和字符串字面量

```
// 字符字面量
'A'

// 字符串字面量，由常量字符构成的数组，每个字符串结尾处多一个 '\0'
"A"
```

转移序列

转义序列将不可打印字符（换行符、回车符）和特殊含义字符（", ', ?）等表示出来；

```
\n
\b
\r
\"
\'
```

可以在字面量中添加前缀或后缀改变字面量的类型

![](http://o97duqgf5.bkt.clouddn.com/18-2-3/70441607.jpg)

- 复合类型

基于其他类型定义的类型，这里介绍引用和指针；

**引用：**
为对象起别名，程序会把引用和对象的初始值绑定在一块；

```cpp

int a = 1;

int &r = a;

int &r1; // 错误，引用必须被初始化

```

[注]
引用本身不是一个对象，所以不能定义引用的引用；

一般情况下，引用的类型都要和与之绑定的对象严格匹配，并且不能与字面量或是表达式绑定在一起；

**指针：**

**自定义数据结构：**

- 抽象数据类型

字符串、向量和数组

C++ 提供丰富的抽象数据类型库，其中内置数据是一种基础的类型，string 和 vector 都是数组对它的某种抽象，string 支持可变长的字符串，vector 支持可变长的集合，迭代器是二者的配套类型，常用于访问二者的元素。

**字符串**

定义和初始化 string 对象

```cpp
string s1;
string s2 = s1;
string s3(s2);
string s4 = 'hello';
string s5(10, 'a');
```

![](http://o97duqgf5.bkt.clouddn.com/18-2-16/12691831.jpg)

【注】
string 对象的 size 函数返回的是 string::size_type 类型；

比较 string 对象；

![](http://o97duqgf5.bkt.clouddn.com/18-2-16/6890947.jpg)

字面值和 string 对象的相加时，确保每个加法运算符的两侧的运算对象至少有一个是 string，注意字符串字面值与 string 不是同类型；

**向量**

vector 表示类型相同的对象集合。

【tips】

关于模板，模板本身不是类或函数，可以将其看做编译器生成类或函数编写的一份说明，C++ 语言及包含类模板也包括函数模板。

编译器根据模板创建类或函数的过程称为实例化。

定义和初始化 vector 对象

![](http://o97duqgf5.bkt.clouddn.com/18-2-17/8858645.jpg)

**迭代器**

迭代器运算符

![](http://o97duqgf5.bkt.clouddn.com/18-2-17/97306872.jpg)

箭头运算符（->）把解引用和成员访问两个操作结合在一起，即

```cpp
it->mem
// 等价于
(*it).mem
```

**数组**

与 vector 相似的是，数组是存放类型相同的对象的容器，但数组的大小确定不变，不能随意向数组中增加元素。

如果通过表达式给数组限制维度的话，则表达式必须为常量表达式；

```cpp
unsigned cnt = 42;
constexpr unsigned sz = 42;

int arr[cnt]; // cnt 不是常量表达式
int arr2[sz]; // sz 是常量表达式
```

![](http://o97duqgf5.bkt.clouddn.com/18-2-18/41068969.jpg)

![](http://o97duqgf5.bkt.clouddn.com/18-2-18/15252644.jpg)

C++ 的数组不允许拷贝与赋值

![](http://o97duqgf5.bkt.clouddn.com/18-2-18/9636228.jpg)

理解数组声明的方法是从数组的名字开始由内向外的顺序阅读；

数组与指针

![](http://o97duqgf5.bkt.clouddn.com/18-2-18/7617087.jpg)

指针也是迭代器

对数组使用下标运算符时，实际是对数组的首元素的指针执行加法运算；

```cpp

int ia[] = {0,2,4,6,8};

int i = ia[2];

// 等价于

int *p = ia;
i = *(p + 2);

```

[tips]

不允许使用一个数组为了另一个数组赋初值，也不允许使用 vector 对象初始化数组；
但允许使用数组来初始化 vector 对象；

![](http://o97duqgf5.bkt.clouddn.com/18-2-18/93076873.jpg)

多维数组初始化

![](http://o97duqgf5.bkt.clouddn.com/18-2-19/79923844.jpg)

使用 range for 遍历多维数组时的注意事项，详见：114 页；

## 3. 表达式

一个最基本的表达式就是字面量和变量组成；

一个一般的表达式由运算符和运算对象组成；

运算符可分为一元运算符、二元运算符和三元运算符等；

对于多个运算符的复杂表达式而言，要理解运算符的优先级、结合律以及运算对象的求值顺序；

重载运算符定义了运算对象的类型和返回值的类型，但是运算对象的个数、运算符的优先级和结合律是无法改变的；

![](http://o97duqgf5.bkt.clouddn.com/18-2-19/66443156.jpg)

【疑问】C++ 的左值和右值不太懂？

来自 Scott Meyers 的方法
判断表达式是否是左值，有一个简单的办法，就是看看能否取它的地址，能取地址的就是左值。

![](http://o97duqgf5.bkt.clouddn.com/18-2-19/72796491.jpg)

算术运算符

逻辑和关系运算符

![](http://o97duqgf5.bkt.clouddn.com/18-2-19/67840992.jpg)

递增/递减运算符

![](http://o97duqgf5.bkt.clouddn.com/18-2-19/70072557.jpg)

成员访问运算符

点运算符和箭头访问运算符都能访问成员

```cpp

string s1 = "hello world", *p = &s1;
auto n = s1.size(); // 点运算符获取类对象的一个成员；
n = (*p).size();
n = p->size(); // 等价于 （*p).size()
```

位运算符

【注】运算符优先级：

算术运算符 > 位运算符 > 关系和逻辑运算符 > 条件运算符


sizeof 运算符返回一条表达式或一个类型名字所占的**字节数**

在使用表达式中进行运算符运算时，常常发生类型转换；
类型转换包括：隐式转换和显示转换；

![](http://o97duqgf5.bkt.clouddn.com/18-2-19/59882331.jpg)

[疑问]强制类型转换不太熟悉？

## 4. 语句

简单语句和复合语句

空语句和语句块

声明语句和表达式语句

条件语句: if 和 switch

循环语句：for / while / do while

跳转语句：break / continue / goto / return

异常检测和处理语句：throw / try catch

## 5. 函数

函数是一个命名的代码块；

C++ 函数的返回类型不能是数组或是函数类型，但可以是指向数组或函数的指针；

parameters: 形参

arguments: 实参

一般而言，函数内部的变量的生命周期为函数调用始终，但我们可以定义局部静态变量，使得函数结束执行时，变量也不被销毁。

```cpp

size_t count_calls()
{
  static size_t ctr = 0;
  return ++ctr;
}

int main()
{
  for (size_t i = 0; i != 10; ++i)
    cout << count_calls() << endl;
  return 0;
}
```

函数的定义与声明：

```cpp
// 声明
void add(int a, int b);

// 定义
void add(int a, int b)
{
  return a + b;
}
```

【tips]
变量在头文件中声明，在源文件中定义；

**分离式编译：**

C++ 的分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译；

![](http://o97duqgf5.bkt.clouddn.com/18-2-20/75202883.jpg)

函数执行时实参的传递可根据形参的定义不同分为值传递和引用传递，拷贝大的类类型对象或容器对象时，一般通过引用形参访问该类型的对象；

如果我们只要对类类型进行读取的话，通常可以吧形参类型定义为常量引用；

[顶层 const 和底层 const]

顶层 const 可以表示任意对象是一个常量，这对于算术类型、类、指针等任何数据类型都是成立的， 底层 const 则与指针和引用等复合类型的基本类型部分有关 ，比较特殊的是，指针既可以是顶层 const 也可以是底层 const ，这一点与其他类型区别明显。

当用实参初始化形参时，会忽略掉顶层 const;



```cpp

const int ci = 42; // 顶层 const，忽略掉顶层 const;

int i = 42;
const int *cp = &i; // 底层 const，cp 指向的变量 i 是一个常量；
// 这里我们可以用一个非常量初始化一个底层 const 对象；
```

通常建议：将函数不会改变的形参定义为常量引用；

**数组形参：**

数组具有两个特殊性质：不允许拷贝数组和使用数组时（通常）会将其转会为指针；

因此，由于无法拷贝数组所以按值传递使用数组参数，当我们为函数传递一个数组时，实际传递的是指向数组首元素的指针；

```cpp
void print(const int *);
void print(const int[]);
void print(const int[10]);
```

由于数组是以指针的形式传递给函数，所以函数不知道数组的数量，为此调用者需要额外传递一些信息，管理数组指针形参的常用有 3 种技术：

使用标记指定数组长度，常用于 C 风格的字符串，其结尾以 '\0' 为标识；

```cpp
void print(const char *cp)
{
  if(cp)
    while(*cp) // 当为空字符时，结束循环；
      cout << *cp++ << endl;
}
```

使用标准库规范

```cpp
void print(const int *beg, const *end)
{
  while (beg != end)
    cout << *beg++ << endl;
}

int j[2] = {0，1}
print(begin(j), end(j));
```

显示传递表示数组大小的形参（过去的 C++ 常用此类方法）

```cpp
void print(const int ia[], size_t size)
{
  for (size_t i = 0; i != size; ++i)
  {
    cout << ia[i] << endl;
  }
}

int j[] = {0, 1}
print(j, end(j) - begin(j))l;
```

传递多维数组时，数组的第一维是指向数组首元素的指针，第二维的大小都是数组类型的一部分；

```cpp
int (*matrix)[10] // 指向 10 个整型数字组成的指针
// 等价于
int matrix[][10]
```

**返回数组指针**

可以使用类型别名、声明一个返回数组指针的函数、尾置返回类型或使用 decltype

```cpp
typedef int arrT[10];
using arrT = int[10];

arrT* func(int i);
```

```cpp
int (*func(int i))[10];
```

```cpp
auto func(inti i) -> int (*)[10];
```

```cpp
int odd[] = {1,3,5};
int even[] = {0,2,4};

decltype(odd) *arrPtr(int i)
{
  return (i % 2) &odd : &even;
}

// decltype 不负责把数组类型转换成对应的指针，所以 decltype 的结果是数组；
```

重载和 const 形参

重载和作用域
1. 如果局部作用域内重载函数，它将把外部作用域的函数给隐藏掉；
2. 如果局部作用域内没有重载函数，那么上述情况将不会发生；

函数相关的语言特性：

1. 默认实参，C++ 规定一旦某个形参赋予默认值后，它后面的所有形参都必须有默认值；
【tips】
C++ 默认实参负责填补函数调用缺少的尾部实参，因此通常在设计默认实参时，尽量将不怎么使用默认值的形参出现在前面，经常使用默认值的形参放在后面；



2. 内联函数

函数具有的优点在于良好封装、语义化、复用性，但是函数的调用是需要开销的，比如保存调用前的状态（状态保存与恢复），实参的拷贝等；

可以将函数定义为内联函数从而避免函数调用时的开销，内联函数就是将它在调用点内联地展开；

内联机制用于优化规模较小、流程直接、频繁调用的函数；

```cpp
inline const string &shorterString(const string &s1, const string &s2)
{
  return s1.size() <= s2.size() ? s1 : s2;
}

cout << shorterString(s1, s2) << endl;
// 编译过程中将展开为
cout << (s1.size() <= s2.size() ? s1 : s2) << endl;
```
![](http://o97duqgf5.bkt.clouddn.com/18-2-21/68145680.jpg)


constexpr 函数

constexpr 函数是指能用于常量表达式的函数，返回的值必须是 constexpr 类型；

其规定函数的返回类型及所有形参都必须是字面值类型；

常量表达式是变量是一个常量并且在编译阶段值可以确定的表达式

```cpp

const int a = 42; // 常量表达式
int b = 42; // 非常量表达式
const int c = get_size(); // 除非 get_size() 是 constexpr 函数
```

重载函数匹配过程如下：

1. 根据调用的函数名和当前作用域的函数声明中从重载函数集中确认候选函数

2. 根据函数调用提供的实参，从候选函数中选出可行函数，选取原则是形参数量和实参是否一致以及实参类型和形参类型是否一致或是可否转换成形参类型；

3. 从可行函数中选取与本次调用最佳匹配的函数；

函数指针：指向函数的指针

```cpp
// function
bool lenCompare(const string &s1, const string &s2);

// function pointer
bool (*fp)(const string &s1, const string &s2);

// 当我们把函数名作为一个值使用时，该函数自动转换为指针
fp = lenCompare
// 等价于
fp = &lenCompare

// 可以直接使用指向函数的指针调用改函数
bool b1 = fp("hello", "goodbye");
bool b2 = (*fp)("hello", "goodbye");
```

## 6. 自定义数据类型（ADT）: 类

使用类自定义数据类型（数据结构）

类的实现基本上就是在封装的过程中实现抽象；

类的基本思想是数据抽象和封装；

数据抽象是一种依赖于接口和实现分离的编程技术；

封装实现了类的接口和实现的分离，封装类之后，用户只能使用接口而无法访问实现细节部分。

![](http://o97duqgf5.bkt.clouddn.com/18-2-21/59516435.jpg)

一般而言：

类的成员函数定义在类的内部，作为接口的组成部分的非成员函数（实现）定义在类的外部；

[疑问] Page231 const 成员函数不太懂？

```cpp
std::string isbn() const { return this->bookNo; };
```

isbn 函数的参数列表之后紧随 const 关键字，这里的 const 是修饰隐式 this 指针的类型；

默认情况下，this 指向非常量版本的常量指针，添加 const 后表示 this 是指向常量的指针；

[tips]

C++ 中函数的声明和定义进行分离；

通常，将函数的声明放在头文件，定义放在源文件；

如果统一放在源文件，那么多个源文件 #include 时将导致函数重复定义；

因此，通过 C++ 的分离式编译机制可以较好的解决这一问题；

**构造函数**

构造函数是类通过一个或几个特殊的成员函数来控制其对象的初始化过程；

默认构造函数：如果我们没有为类的数据成员提供初始值，那么编译器会隐式定义一个默认构造函数；

一般建议，我们要初始化数据成员，因为默认构造函数有一定的缺陷；

【tips】

struct 和 class 定义类的唯一区别在于默认的访问权限；

类在它第一个访问说明符之前定义成员，这种成员的访问权限依赖类定义方式，如果是 struct 则之前的成员是 public，class 则为 private；

**友元**

如果将类的数据成员定义为 private，当非成员函数想要访问其数据成员时，可以在类内部将其声明为友元，需要注意的是友元的声明仅仅指定了访问的权限而非函数声明；

定义在类内部的成员函数是自动 incline 的，如果函数在类的内部声明，在外部进行定义，那么最好在外部定义出使用 inline 修饰符；

可变数据成员

![](http://o97duqgf5.bkt.clouddn.com/18-2-22/88136063.jpg)

类可以把其他的类定义成友元或是把其他类的成员函数定义成友元；

常见的应用场景是：当一个类需要操作另一个类的非公开成员时，这是需要把该类或该类的某个成员函数定义成友元；

```cpp

class Screen {
  friend class Window_mgr;
}

class Window_mgr {
  public:
    us
}
```

**类的成员访问**

作用域运算符：
```
Window_mgr::screen_index; // 定义在类中的变量

Window_mgr wm;

成员访问运算符：点运算符和 -> 访问运算符

wm.clear();

wm->clear();
```

**名字查找**

名字查找就是寻找和所用名字最匹配的声明的过程；

对于定义在类内部的成员函数而言，解析名字的方式分两步处理：

首先，编译成员的声明；
直到类全部可见后才编译函数体；

以上处理方式，使得我们可以在提前使用声明好的名字，然后进行定义；

**构造函数初始化（直接初始化）和赋值（先初始化后赋值）**

有时二者没有区别，但是当成员是 cnost 或是引用时，那么我们必须在初始化列表阶段进行初始化而不能定义一个构造函数进行赋值初始化；

因此，建议使用**构造函数初始值**；

详见 page 284

**成员初始化顺序**
![](http://o97duqgf5.bkt.clouddn.com/18-2-22/56508888.jpg)


**隐式的类类型转换**

在此前定义的 Sales_data 类中，我们可以使用以下方法实现类类型的隐式转换；

```cpp

string null_book = "9-999999";
item.combine(null_book);
```

当然，我们也可以要求不允许构造函数进行隐式转换；

```cpp

class Sales_data {
  explicit Sales_data(const std::string& s) : bookNo(s) {}
}
```

关机子 explicit 只对一个实参的构造函数有效，需要多个实参的构造函数是不能执行隐式转换的；

[疑问？] constexpr 与字面值常量类这块不是很明白 ？




